//

// CServConsoleD.cpp

// Copyright 1996 - 2001 Menace Software (www.menasoft.com)

// Put up a DOS type console for output.



#include "stdafx.h"	// predef header.

#include <signal.h>



#ifdef _CONSOLE

#ifndef _WIN32

#include <vga.h>	// reverting to libvga -- don't like curses

#endif



#ifdef _WIN32



BOOL WINAPI ConsoleHandlerRoutine( DWORD dwCtrlType )

{

	//  control signal type. CTRL_C_EVENT

	// SetConsoleCtrlHandler

	switch ( dwCtrlType )

	{

	case CTRL_C_EVENT: // A CTRL+c signal was received, either from keyboard input or from a signal generated by the GenerateConsoleCtrlEvent function.

	case CTRL_BREAK_EVENT: //  A CTRL+BREAK signal was received, either from keyboard input or from a signal generated by GenerateConsoleCtrlEvent.

	case CTRL_CLOSE_EVENT: // A signal that the system sends to all processes attached to a console when the user closes the console (either by choosing the Close command from the console window's System menu, or by choosing the End Task command from the Task List).

		if ( g_Cfg.m_fSecure && ! g_Serv.IsLoading())	// enable the try code.

		{

#if 0

			// this never worked.

			g_Serv.WriteString( "Press 'y' to exit safely, 'x' to exit immediatly." );

			for(;;)

			{

				int ch = _getch();

				if ( ch == 0 )

					continue;

				ch = toupper( ch );

				if ( ch == 'X' )

					return( FALSE );

				if ( ch != 'Y' )

					return( TRUE );

				break;

			}

#endif

			g_Serv.SetExitFlag( SPHEREERR_CTRLC );

			return( TRUE );

		}

		break;

	case CTRL_LOGOFF_EVENT: // A signal that the system sends to all console processes when a user is logging off. This signal does not indicate which user is logging off, so no assumptions can be made.

	case CTRL_SHUTDOWN_EVENT: // A signal that the system sends to all console processes when the system is shutting down

		break;

	}

	return FALSE;	// process normally.

}



#endif	// _WIN32



#ifdef _WIN32

bool CServConsole::Init( HINSTANCE hInstance, LPSTR lpCmdLinel, int nCmdShow )

#else

bool CServConsole::Init( LPSTR lpCmdLinel, int nCmdShow )

#endif

{

#ifdef _WIN32

	SetConsoleTitle( SPHERE_TITLE " V" SPHERE_VERSION );

	SetConsoleCtrlHandler( ConsoleHandlerRoutine, true );

#endif

	return true;

}

void CServConsole::Exit()

{

#ifdef _WIN32

	SetConsoleCtrlHandler( ConsoleHandlerRoutine, false );

#endif



	// allow the user to see the error.

	if ( g_Serv.m_iExitFlag < 0 )

	{

		WriteString( "Press any key to exit" );

#ifdef _WIN32

		while ( _getch() == 0 ) 

#else

		while ( vga_getkey() == 0 ) 

#endif

		{

			Sleep(500);

		}

	}



}

void CServConsole::SetMessageColorType( int iColorType )

{

#ifdef _WIN32

	static const DWORD sm_Colors[] = 

	{

		FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE,	// body

		FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY, // time. 

		FOREGROUND_RED|BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|FOREGROUND_INTENSITY, // error label.

		BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|FOREGROUND_INTENSITY, // context (Scripts)

	};

	SetConsoleTextAttribute( GetStdHandle(STD_OUTPUT_HANDLE), sm_Colors[iColorType] );

#endif

}

bool CServConsole::WriteString( const char* pszMsg )

{

	if ( pszMsg == NULL || ISINTRESOURCE(pszMsg))

		return false;

	fputs( pszMsg, stdout );

	return true;

}

bool CServConsole::OnTick( int iWaitmSec )

{

	// Wait in here for iWaitmSec

	// RETURN: 

	//  false = exit the app.



	DWORD dwTimeStart = ::GetTickCount();

	int iChar;

#ifdef _WIN32

	while ( _kbhit())

	{

		iChar = _getche();	// Get char and echo.

#else // _WIN32

	while ( iChar = vga_getkey())

	{

#endif // ! _WIN32

		int iRet = AddConsoleKey( m_sConsoleText, iChar, false );

		if ( iRet == 2 )

		{

			m_fConsoleTextReadyFlag = true;

		}



		if ( ::GetTickCount() - dwTimeStart >= iWaitmSec )

			return true;

	}

	return true;

}



void CServConsole::OnTriggerEvent( SERVTRIG_TYPE type, DWORD dwArg1, DWORD dwArg2 )

{

	CGString sStatus;



	switch(type)

	{

	case SERVTRIG_ServerMsg:

	case SERVTRIG_Startup:

		SetMessageColorType( dwArg2 );

		WriteString( (LPCSTR) dwArg1 );

		return;

	case SERVTRIG_LoadStatus:

	case SERVTRIG_TestStatus:

	case SERVTRIG_GarbageStatus:

	case SERVTRIG_SaveStatus:

		sStatus.Format( "%d%%", MulDiv( dwArg1, 100, dwArg2 ));



	case SERVTRIG_ModeChange:

#ifdef _WIN32

		{

		CGString sTitle;

		sTitle.Format( SPHERE_TITLE " V" SPHERE_VERSION " - %s (%s) %s", 

			(LPCSTR) g_Serv.GetName(), 

			(LPCSTR) g_Serv.GetModeDescription(), 

			sStatus );

		SetConsoleTitle( sTitle );

		}

#endif

		return;

	}

}



#endif	// _CONSOLE



